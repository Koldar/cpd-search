#ifndef _CPDSEARCH_CPDJUMPSEARCH_HEADER__
#define _CPDSEARCH_CPDJUMPSEARCH_HEADER__

#include <cpp-utils/listeners.hpp>

#include <pathfinding-utils/ISearchAlgorithm.hpp>
#include <pathfinding-utils/GraphState.hpp>
#include <pathfinding-utils/IStatePruner.hpp>
#include <pathfinding-utils/NeverPrune.hpp>
#include <pathfinding-utils/StandardLocationGoalChecker.hpp>
#include <pathfinding-utils/IStateSupplier.hpp>

#include <compressed-path-database/CpdManager.hpp>

#include "CpdStateSupplier.hpp"
#include "CpdState.hpp"
#include "CpdExpander.hpp"
#include "CpdJumpSearchListener.hpp"
#include "PerturbatedCost.hpp"
#include "CpdFocalHeuristic.hpp"


namespace pathfinding::search {

    using namespace cpp_utils;
    using namespace compressed_path_database;
    using namespace pathfinding::search;

    /**
     * @brief CPD Jump search
     * 
     * A possible better improvement of CPD Search
     * 
     * Perturbations
     * =============
     * 
     * Each perturbation:
     * @li can only increase an edge-cost, not decrease it;
     * @li is uniquely identified by the edge it involves, the new edge cost associated;
     * @li detected at the beginning of the path planning episode and then assumed static;
     * 
     * Feature
     * =======
     * 
     * - as heuristic we still use CpdHeuristic;
     * - if the cpdpath(n, g) do not have perturbations, we early terminate;
     * - use the bounded algorithm from ijcai2019 (path planning with cpd heuristics);
     * - the upperbound is retrieved by simulating the path generated by cpdpath(n,g);
     * - given a state, we generate all the direct successors plus the successor generated by following the cpd pathup until the first perturbation;
     * - we use only the open list, no focal list. Tie breaking with state with same f_min are broken by considering max g;
     * - the approach generates suboptimal solutions;
     * - the approach can generate quick suoptimal solutions if  the costs are infinites
     * 
     * The new successor leads to suboptimality, but instead of being guided by a focal search it is guided by the still informed cpd heuristics. So hopefully can reach the goal quickly. More importantly, it handles infinites costs gracefully w.r.t. cpd search. Cpd search cannot generate a solution if even one edge along the cpd path has infinite cost. CpdJumpSearch has this problem as well, but it mitigates it by finding new suboptimal path by immediately launching it self near the perturbation, like so:
     * 
     * @image html cpdjumpsearch01.jpg "cpd jump search exapnsion states" 
     * 
     * This is especially favourable if the perturbation is wide and near the goal: cpdsearch needs to expand all the  state in a "triangle" until it reaches one solution (which in the example below is also the optimal one):
     * 
     * @image html cpdjumpsearch02.jpg "cpd jump search exapnsion states" 
     * 
     * Of course some problem are still a problem for cod jump search as well:
     * 
     * @image html cpdjumpsearch03.jpg "cpd jump search exapnsion states" 
     * 
     * State
     * =====
     * 
     * The state is GraphState. the states are over the perturbated graph. It's not a big deal since GraphState uses the underlying graph only for <<.
     * 
     * 
     * 
     * 
     * @tparam G type of the payload of the underlying map graph
     * @tparam V type of the payload of each vertex in map graph
     */
    template <typename G, typename V>
    class CpdJumpSearch: public IMemorable, public ISearchAlgorithm<CpdState<G, V, PerturbatedCost>, const CpdState<G, V, PerturbatedCost>*, const CpdState<G, V, PerturbatedCost>&>, public ISingleListenable<listeners::CpdJumpSearchListener<G, V, CpdState<G, V, PerturbatedCost>>> {
        using GraphStateReal = CpdState<G, V, PerturbatedCost>;
        using This =  CpdJumpSearch<G, V>;
        using Listener = listeners::CpdJumpSearchListener<G, V, GraphStateReal>;
        using Super2 = ISingleListenable<Listener>;
    public:
        /**
         * @brief Construct a new Time Cpd Search object
         * 
         * @param heuristic 
         * @param goalChecker 
         * @param supplier 
         * @param expander 
         * @param pruner 
         * @param cpdManager cpd manager that will be used to poll the cpd. It needs to be already loaded
         * @param epsilon suboptimality bound to test
         * @param openListCapacity 
         */
        CpdJumpSearch(CpdFocalHeuristic<GraphStateReal, G, V>& heuristic, IGoalChecker<GraphStateReal>& goalChecker, IStateSupplier<GraphStateReal, nodeid_t>& supplier, CpdExpander<G, V, GraphStateReal>& expander, IStatePruner<GraphStateReal>& pruner, const CpdManager<G,V>& cpdManager, fractional_cost epsilon, unsigned int openListCapacity = 1024) : Super2{},
            heuristic{heuristic}, goalChecker{goalChecker}, supplier{supplier}, expander{expander}, pruner{pruner},
            epsilon{epsilon}, cpdManager{cpdManager},
            openList{nullptr} {
                debug("CpdJumpSearch constructor started!");
                if (!heuristic.isConsistent()) {
                    throw cpp_utils::exceptions::InvalidArgumentException{"the heuristic is not consistent!"};
                }
                this->openList = new StaticPriorityQueue<GraphStateReal>{openListCapacity, true};
                debug("CpdJumpSearch constructor ended!");
            }

        virtual ~CpdJumpSearch() {
            this->tearDownSearch();
            delete this->openList;
        }
        //the class cannot be copied whatsoever
        CpdJumpSearch(const This& other) = delete;
        CpdJumpSearch& operator=(const This& other) = delete;

        CpdJumpSearch(This&& other): Super2{std::move(other)}, heuristic{other.heuristic}, goalChecker{other.goalChecker}, supplier{other.supplier}, expander{other.expander}, pruner{other.pruner}, epsilon{other.epsilon}, cpdManager{other.cpdManager}, openList{other.openList} {
            other.openList = nullptr;
        }

        CpdJumpSearch& operator=(This&& other) {
            Super2::operator=(::std::move(other));

            this->heuristic = other.heuristic;
            this->goalChecker = other.goalChecker;
            this->supplier = other.supplier;
            this->expander = other.expander;
            this->pruner = other.pruner;
            this->epsilon = other.epsilon;
            this->cpdManager = other.cpdManager;
            this->openList = other.openList;
            other.openList = nullptr;
            return *this;
        }

    public:
        virtual MemoryConsumption getByteMemoryOccupied() const {
            throw cpp_utils::exceptions::NotYetImplementedException{__func__};
        }
    private:
        /**
         * @brief parameter that allows us to tweak the suboptimality bound of the algorithm
         * 
         */
        fractional_cost epsilon;
        /**
         * @brief manager of cpd
         * 
         */
        const CpdManager<G, V>& cpdManager;
        CpdFocalHeuristic<GraphStateReal, G, V>& heuristic;
        IGoalChecker<GraphStateReal>& goalChecker;
        CpdExpander<G, V, GraphStateReal>& expander;
        IStateSupplier<GraphStateReal, nodeid_t>& supplier;
        IStatePruner<GraphStateReal>& pruner;
        StaticPriorityQueue<GraphStateReal>* openList;
    public:
        virtual std::string getName() const {
            return "CPD-Jump-Search";
        }
        virtual void setupSearch(const GraphStateReal* start, const GraphStateReal* goal) {
            //cleanup before running since at the end we may want to poll information on the other structures
            this->heuristic.cleanup();
            this->expander.cleanup();
            this->supplier.cleanup();
            this->pruner.cleanup();
            this->openList->clear();
            
            this->listener->cleanup();
        }
        virtual void tearDownSearch() {
        }
    protected:
        virtual cost_t computeF(cost_t g, cost_t h) const {
            return g + h;
        }
    protected:
        virtual std::unique_ptr<ISolutionPath<const GraphStateReal*, const GraphStateReal&>> buildSolutionFromGoalFetched(const GraphStateReal& start, const GraphStateReal& actualGoal, const GraphStateReal* goal) {
            auto result = new StateSolutionPath<GraphStateReal>{};
            const GraphStateReal* tmp = &actualGoal;
            while (tmp != nullptr) {
                debug("adding ", tmp, "to solution");
                result->addHead(tmp);
                tmp = tmp->getParent();
            }
            return std::unique_ptr<StateSolutionPath<GraphStateReal>>{result};
        }
        virtual cost_t getSolutionCostFromGoalFetched(const GraphStateReal& start, const GraphStateReal& actualGoal, const GraphStateReal* goal) const {
            return actualGoal.getCost();
        }
        virtual const GraphStateReal& performSearch(GraphStateReal& start, const GraphStateReal* expectedGoal) {
            info("*********************** NEW SEARCH *******************");
            if (expectedGoal != nullptr) {
                info("starting A*! start = ", start, "goal = ", *expectedGoal);
            } else {
                info("starting A*! start = ", start, "goal = ", "none");
            }
            

            int aStarIteration = 0;
            const GraphStateReal* goal = nullptr;
            cost_t upperbound = cost_t::INFTY;
            //we might be able to early terminate from start. In this case the state where we start early terminating is the start itself
            const GraphStateReal* earlyTerminationState = &start;

            start.setG(0);
            this->fireEvent([&start, aStarIteration](Listener& l) {l.onStartingComputingHeuristic(aStarIteration, start); });
            start.setH(this->heuristic.getHeuristic(start, expectedGoal));
            this->fireEvent([&start, aStarIteration](Listener& l) {l.onEndingComputingHeuristic(aStarIteration, start); });
            start.setF(this->computeF(start.getG(), start.getH()));

            //update lastEarliestPerturbationSourceId
            start.updateEarlyPerturbationInfo(
                this->heuristic.getLastEarliestNodeBeforePerturbation(),
                this->heuristic.getLastEarliestPerturbationSourceIdCost()
            );

            //update lower and upper bound from f of solution
            cost_t lowerbound = start.getH();
            upperbound = this->heuristic.getCPDPathPerturbatedWeights(start.getPosition());

            this->openList->push(start);
            while (!this->openList->isEmpty()) {
                info("*************** A* step #", aStarIteration, "******************");
                GraphStateReal& current = this->openList->peek();
                //current.getF() is also a lowerbound since the heuristic is admissible
                lowerbound = current.getF();
                info("state ", current, "popped from open list f=", current.getF(), "g=", current.getG(), "h=", current.getH(), " pointer=", &current, "parent pointer=", current.getParent(), "lowerbound=", lowerbound, "upperbound=", upperbound, "eps_numerator=", this->epsilon.getNumerator(), "eps_denominator=", this->epsilon.getDenominator());

                //check if the peeked state is actually a goal
                if (this->goalChecker.isGoal(current, expectedGoal)) {
                    info("state ", current, "is a goal!");
                    goal = &current;

                    this->fireEvent([&, goal](Listener& l) { l.onSolutionFound(aStarIteration, *goal);});
                    goto goal_found;
                }

                this->openList->pop();
                

                /*
                * upperbound/lowebound <= epsilon 
                * which we derive
                * eps * lowerbound >= upperbound
                */
               info("(", this->epsilon.getNumerator(), "*", current.getF(), ") >= (", upperbound, "*", this->epsilon.getDenominator(), ")");
                if ((this->epsilon.getNumerator() * current.getF()) >= (upperbound * this->epsilon.getDenominator())) {
                    //return the solution by concatenating the current path from start to current and the cpdpath from current to goal
                    //(considering the perturbations!)
                    info("epsilon * lowerbound >= upperbound! ", epsilon, "*", current.getF(), ">=", upperbound);
                    info("early terminating from ", *earlyTerminationState, "up until ", *expectedGoal);
                    goal = this->earlyTerminate(*earlyTerminationState, expectedGoal);
                    this->fireEvent([&, earlyTerminationState, goal, aStarIteration](Listener& l) {l.onEarlyTerminationActivated(aStarIteration, *earlyTerminationState, *goal); });
                    this->fireEvent([&, goal](Listener& l) { l.onSolutionFound(aStarIteration, *goal);});
                    goto goal_found;
                }

                current.markAsExpanded();
                this->fireEvent([&current, aStarIteration](Listener& l) {l.onNodeExpanded(aStarIteration, current); });

                info("computing successors of state ", current, "...");
                for(auto pair: this->expander.getSuccessors(current, this->supplier)) {
                    GraphStateReal& successor = pair.first;
                    cost_t current_to_successor_cost = pair.second;

                    if (this->pruner.shouldPrune(successor)) {
                        info("child", successor, "of state ", current, "should be pruned!");
                        //skip neighbours already expanded
                        continue;
                    }

                    //update lastEarliestPerturbationSourceId
                    start.updateEarlyPerturbationInfo(
                        this->heuristic.getLastEarliestNodeBeforePerturbation(),
                        this->heuristic.getLastEarliestPerturbationSourceIdCost()
                    );

                    debug("checking successor", successor, "w.r.t upperbound", upperbound);
                    if (successor.getG() > upperbound) {
                        //we put tjhis successor in closed list, since it cannot be the solution, since its cost is greater than the current solution
                        successor.setExpanded(true);
                        info(successor, "put in closed list since its g is far superior than the upperbound", upperbound);
                        continue;
                    }

                    // the search is suboptimal. So a state in the closed list can be reopened
                    if (this->openList->contains(successor)) {
                        //state inside the open list. Check if we need to update the path
                        cost_t gval = current.getG() + current_to_successor_cost;
                        if (gval >= successor.getG()) {
                            cinfo(successor, " is in open but the new path for reaching the state is not better than the current one. Ignoring");
                            continue;
                        }

                        info("child", successor, "of state ", current, "present in open list and has a lower g. update its parent!");

                        //update successor information
                        successor.setG(gval);
                        successor.setF(this->computeF(gval, successor.getH()));
                        const GraphStateReal* oldParent = successor.getParent();
                        successor.setParent(&current);

                        this->openList->decrease_key(successor);
                    } else if (successor.isExpanded()) {
                        //state is in closed list. Check if we need to put it in open again
                        cost_t gval = current.getG() + current_to_successor_cost;
                        if (gval >= successor.getG()) {
                            info(successor, " is in closed but the new path for reaching the state is not better than the current one. Ignoring");
                            continue;
                        }
                        info("child", successor, "of state ", current, "present in closed list and has a lower g. update its parent and put it in open again!");
                        successor.setExpanded(false);

                        //update successor information
                        successor.setG(gval);
                        successor.setF(this->computeF(gval, successor.getH()));
                        const GraphStateReal* oldParent = successor.getParent();
                        successor.setParent(&current);

                        this->openList->push(successor);
                    } else {
                        //state is not present in open list. Add to it
                        cost_t gval = current.getG() + current_to_successor_cost;
                        this->fireEvent([&successor, aStarIteration](Listener& l) {l.onStartingComputingHeuristic(aStarIteration, successor); });
                        cost_t hval = this->heuristic.getHeuristic(successor, expectedGoal);
                        this->fireEvent([&successor, aStarIteration](Listener& l) {l.onEndingComputingHeuristic(aStarIteration, successor); });

                        //update lastEarliestPerturbationSourceId
                        successor.updateEarlyPerturbationInfo(
                            this->heuristic.getLastEarliestNodeBeforePerturbation(),
                            this->heuristic.getLastEarliestPerturbationSourceIdCost()
                        );
                        
                        successor.setG(gval);
                        successor.setH(hval);
                        successor.setF(this->computeF(gval, hval));
                        successor.setParent(&current);
                        this->fireEvent([&successor, aStarIteration](Listener& l) {l.onNodeGenerated(aStarIteration, successor); });

                        //we may have a new upperbound of the solution
                        if (upperbound > gval + this->heuristic.getLastPerturbatedCost()) {
                            info("updating upperbound. upperbound: from", upperbound, "to", gval + this->heuristic.getLastPerturbatedCost());
                            if (earlyTerminationState == nullptr) {
                                info("updating incumbent. incumbent: from null to", successor);
                            } else {
                                info("updating incumbent. incumbent: from", *earlyTerminationState, "to", successor);
                            }
                            
                            auto newupperbound = gval + this->heuristic.getLastPerturbatedCost();
                            this->fireEvent([&successor, &upperbound, &newupperbound, aStarIteration](Listener& l) {l.onUpperboundRevised(aStarIteration, successor, upperbound, newupperbound); });
                            upperbound = newupperbound;

                            earlyTerminationState = &successor;
                        }

                        info("child", successor, "of state ", current, "not present in open list. Add it f=", successor.getF(), "g=", successor.getG(), "h=", successor.getH());
                        this->openList->push(successor);
                    }
                }

                aStarIteration += 1;
            }
            info("found no solutions!");
            throw SolutionNotFoundException{};

            goal_found:
            return *goal;

        }
    private:
        const GraphStateReal* earlyTerminate(const GraphStateReal& state, const GraphStateReal* expectedGoal) {
            moveid_t nextMove;
            nodeid_t nextVertex;
            cost_t originalMoveCost;
            const GraphStateReal* currentState = &state;
            nodeid_t goalVertex = expectedGoal->getPosition();
            
            while (true) {
                if (this->goalChecker.isGoal(*currentState, expectedGoal)) {
                    return currentState;
                }
                if (this->cpdManager.getFirstMove(currentState->getPosition(), goalVertex, nextMove, nextVertex, originalMoveCost)) {
                    std::pair<GraphStateReal&, cost_t> pair = this->expander.getSuccessor(*currentState, nextMove, this->supplier);
                    GraphStateReal& successor = pair.first;
                    cost_t actionCost = pair.second;
                    successor.setParent(const_cast<GraphStateReal*>(currentState));
                    successor.setG(currentState->getG() + actionCost);
                    successor.setH(cost_t::INFTY);
                    currentState = &successor;
                } else {
                    throw cpp_utils::exceptions::ImpossibleException{};
                }
            }
        }
    };

    /**
     * @brief simple class that create the cpd jump search more easily
     * 
     */
    class CpdJumpSearchFactory {
    public:
        template <typename G, typename V>
        struct output_t {
        public:
            using GraphStateReal = CpdState<G, V, PerturbatedCost>;
        public:
            /**
             * @brief place where the goal checker is located in memory
             * 
             */
            StandardLocationGoalChecker<GraphStateReal> goalChecker;
            /**
             * @brief place where the state supplier is located in memory
             * 
             */
            CpdStateSupplier<G, V, PerturbatedCost> stateSupplier;
            /**
             * @brief place where the state expander is located in memory
             * 
             */
            CpdExpander<G, V, GraphStateReal> stateExpander;
            /**
             * @brief place where the state pruner is located in memory
             * 
             */
            NeverPrune<GraphStateReal> statePruner;
            /**
             * @brief place where the heuristic is located
             * 
             * @note this needs to be the last field declared here, since its dependent on other fields.
             * @see https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP53-CPP.+Write+constructor+member+initializers+in+the+canonical+order
             */
            CpdFocalHeuristic<GraphStateReal, G, V> heuristic;
            /**
             * @brief place where CPD timed search algorithm is located
             * 
             * @note this needs to be the last field declared here, since its dependent on other fields.
             * @see https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP53-CPP.+Write+constructor+member+initializers+in+the+canonical+order
             */
            CpdJumpSearch<G, V> search;
        public:
            output_t(
                const CpdManager<G, V>& cpdManager,
                const IImmutableGraph<G, V, PerturbatedCost>& perturbatedGraph,
                fractional_cost epsilon
                ): 
                goalChecker{}, 
                heuristic{cpdManager, perturbatedGraph},
                stateSupplier{perturbatedGraph}, 
                stateExpander{perturbatedGraph}, 
                statePruner{},
                search{this->heuristic, this->goalChecker, this->stateSupplier, this->stateExpander, this->statePruner, this->heuristic.getCpdManager(), epsilon, 1024} {
                    debug("output factory constructor correctly called!");
            }

            output_t(const output_t& other) = delete;
            output_t(output_t&& other) noexcept : search{::std::move(other.search)}, heuristic(std::move(other.heuristic)), goalChecker(std::move(other.goalChecker)), stateSupplier(std::move(other.stateSupplier)), stateExpander(std::move(other.stateExpander)), statePruner(std::move(other.statePruner)) {
                debug("output factory move constructor correctly called!");
            }
            output_t& operator =(const output_t& other) = delete;
            output_t& operator =(output_t&& other) {
                debug("calling factory move =!");
                this->search = std::move(other.search);
                this->heuristic = std::move(other.heuristic);
                this->goalChecker = std::move(other.goalChecker);
                this->stateSupplier = std::move(other.stateSupplier);
                this->stateExpander = std::move(other.stateExpander);
                this->statePruner = std::move(other.statePruner);

                debug("output factory move = correctly called!");
                return *this;
            }
            virtual ~output_t() {
                debug("output destructed!");
            }
        };
    public:
        /**
         * @brief cpd search on gridmaps
         * 
         * @tparam G payload of the whole graph involved
         * @tparam V payload of a single vertex in the graph
         * 
         * @param[in] cpdManager manager for the cpd. 
         * @param[in] perturbations the perturbation you want to apply to the graph
         * @param[in] epsilon bound
         * @return cpd search algorithm
         */
        template <typename G, typename V>
        output_t<G,V>* get(const CpdManager<G,V>& cpdManager, const IImmutableGraph<G, V, PerturbatedCost>& perturbatedGraph, fractional_cost epsilon) {
            debug("generating output...");
            return new output_t<G, V>{
                cpdManager,
                perturbatedGraph,
                epsilon
            };
        }
    };

}

#endif