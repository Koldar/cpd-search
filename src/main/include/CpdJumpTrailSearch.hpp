#ifndef _CPDSEARCH_CPDJUMPSEARCH_HEADER__
#define _CPDSEARCH_CPDJUMPSEARCH_HEADER__

#include <cpp-utils/listeners.hpp>

#include <pathfinding-utils/ISearchAlgorithm.hpp>
#include <pathfinding-utils/GraphState.hpp>
#include <pathfinding-utils/IStatePruner.hpp>
#include <pathfinding-utils/NeverPrune.hpp>
#include <pathfinding-utils/StandardLocationGoalChecker.hpp>
#include <pathfinding-utils/IStateSupplier.hpp>

#include <compressed-path-database/CpdManager.hpp>

#include "DiscountedCpdStateSupplier.hpp"
#include "DiscountedCpdState.hpp"
#include "CpdTrailExpander.hpp"
#include "CpdJumpTrailSearchListener.hpp"
#include "PerturbatedCost.hpp"
#include "CpdFocalHeuristic.hpp"


namespace pathfinding::search {

    using namespace cpp_utils;
    using namespace compressed_path_database;

    /**
     * @brief CPD Jump Trail Search
     * 
     * A possible better improvement of CPD Search
     * 
     * This is like CPD Jump Search but this time when we create the successor of a state by following the cpd path of it, we put in the open list all the states we go through, creating a "trail".
     * The main idea is that in this way we avoid expanding again all the states we have been through via the cpd path and we can immediately expand the most promising one (maybe it was one in the middle of the track).
     * In this way the search is still best first, so as soon as we find the goal, we know it's the optimal solution.
     * CPD-Search expands all the triangle from the start till to goal if a perturbation is blocking the path. We still expand a triangle, but (hopefully) a smaller one and we can also jump in an optimal way towards the perturbation.
     * If we found a new path that allows us to reach a state in the open list quicker, not only we need to revise the g value, but the h value as well since the discount factor may have changed.
     * When generating a new state, we need to make sure to update the f value taking into account the discount factor.
     * 
     * 
     * @image html cpdjumptrailsearch_01.jpg "cpd jump trail search exapnsion states" 
     * 
     * Perturbations
     * =============
     * 
     * Each perturbation:
     * @li can only increase an edge-cost, not decrease it;
     * @li is uniquely identified by the edge it involves, the new edge cost associated;
     * @li detected at the beginning of the path planning episode and then assumed static;
     * 
     * Feature
     * =======
     * 
     * - as heuristic we still use CpdHeuristic;
     * - if the cpdpath(n, g) do not have perturbations, we early terminate;
     * - use the bounded algorithm from ijcai2019 (path planning with cpd heuristics);
     * - the upperbound is retrieved by simulating the path generated by cpdpath(n,g);
     * - given a state, we generate all the direct successors plus all the successors generated by iteratively following the cpd pathup until the first perturbation;
     * - we use only the open list, no focal list. Tie breaking with state with same f_min are broken by considering max g;
     * - the approach generates optimal solutions;
     * - the approach can generate suoptimal solutions if the costs are infinites (performances may be an issue);
     * 
     * State
     * =====
     * 
     * The state is GraphState. the states are over the perturbated graph. It's not a big deal since GraphState uses the underlying graph only for <<.
     * 
     * 
     * 
     * 
     * @tparam G type of the payload of the underlying map graph
     * @tparam V type of the payload of each vertex in map graph
     */
    template <typename G, typename V>
    class CpdJumpTrailSearch: public IMemorable, public ISearchAlgorithm<DiscountedCpdState<G, V, PerturbatedCost, cpd_search_generated_e>>, public ISingleListenable<listeners::CpdJumpTrailSearchListener<G, V, DiscountedCpdState<G, V, PerturbatedCost, cpd_search_generated_e>>> {
        using State = DiscountedCpdState<G, V, PerturbatedCost, cpd_search_generated_e>;
        using This =  CpdJumpTrailSearch<G, V>;
        using Listener = listeners::CpdJumpTrailSearchListener<G, V, State>;
        using Super2 = ISingleListenable<Listener>;
        using Supplier = DiscountedCpdStateSupplier<G, V, PerturbatedCost>;
        using Expander = CpdTrailExpander<G, V, State>;
    public:
        /**
         * @brief Construct a new Time Cpd Search object
         * 
         * @param heuristic 
         * @param goalChecker 
         * @param supplier 
         * @param expander 
         * @param pruner 
         * @param cpdManager cpd manager that will be used to poll the cpd. It needs to be already loaded
         * @param epsilon suboptimality bound to test
         * @param openListCapacity 
         */
        CpdJumpTrailSearch(CpdFocalHeuristic<State, G, V>& heuristic, IGoalChecker<State>& goalChecker, Supplier& supplier, Expander& expander, IStatePruner<State>& pruner, const CpdManager<G,V>& cpdManager, fractional_cost epsilon, unsigned int openListCapacity = 1024) : Super2{},
            heuristic{heuristic}, goalChecker{goalChecker}, supplier{supplier}, expander{expander}, pruner{pruner},
            epsilon{epsilon}, cpdManager{cpdManager},
            openList{nullptr} {
                debug("CpdJumpTrailSearch constructor started!");
                if (!heuristic.isConsistent()) {
                    throw cpp_utils::exceptions::InvalidArgumentException{"the heuristic is not consistent!"};
                }
                this->openList = new StaticPriorityQueue<State>{openListCapacity, true};
                debug("CpdJumpTrailSearch constructor ended!");
            }

        virtual ~CpdJumpTrailSearch() {
            this->tearDownSearch();
            delete this->openList;
        }
        //the class cannot be copied whatsoever
        CpdJumpTrailSearch(const This& other) = delete;
        CpdJumpTrailSearch& operator=(const This& other) = delete;

        CpdJumpTrailSearch(This&& other): Super2{std::move(other)}, heuristic{other.heuristic}, goalChecker{other.goalChecker}, supplier{other.supplier}, expander{other.expander}, pruner{other.pruner}, epsilon{other.epsilon}, cpdManager{other.cpdManager}, openList{other.openList} {
            other.openList = nullptr;
        }

        CpdJumpTrailSearch& operator=(This&& other) {
            Super2::operator=(::std::move(other));

            this->heuristic = other.heuristic;
            this->goalChecker = other.goalChecker;
            this->supplier = other.supplier;
            this->expander = other.expander;
            this->pruner = other.pruner;
            this->epsilon = other.epsilon;
            this->cpdManager = other.cpdManager;
            this->openList = other.openList;
            other.openList = nullptr;
            return *this;
        }

    public:
        virtual MemoryConsumption getByteMemoryOccupied() const {
            throw cpp_utils::exceptions::NotYetImplementedException{__func__};
        }
    private:
        /**
         * @brief parameter that allows us to tweak the suboptimality bound of the algorithm
         * 
         */
        fractional_cost epsilon;
        /**
         * @brief manager of cpd
         * 
         */
        const CpdManager<G, V>& cpdManager;
        CpdFocalHeuristic<State, G, V>& heuristic;
        IGoalChecker<State>& goalChecker;
        Expander& expander;
        Supplier& supplier;
        IStatePruner<State>& pruner;
        StaticPriorityQueue<State>* openList;
    public:
        virtual std::string getName() const {
            return "CPD-Jump-Search";
        }
        virtual void setupSearch(const State* start, const State* goal) {
            //cleanup before running since at the end we may want to poll information on the other structures
            this->heuristic.cleanup();
            this->expander.cleanup();
            this->supplier.cleanup();
            this->pruner.cleanup();
            this->openList->clear();
            
            this->listener->cleanup();
        }
        virtual void tearDownSearch() {
        }
    protected:
        virtual cost_t computeF(cost_t g, cost_t h, double discountFactor) const {
            // we don't want to overestimate the value. So if we need to round the discount, we prefer rounding it down.
            return g + floor(discountFactor * static_cast<double>(h)); 
        }
    protected:
        virtual std::unique_ptr<ISolutionPath<State>> buildSolutionFromGoalFetched(const State& start, const State& actualGoal, const State* goal) {
            auto result = new StateSolutionPath<State>{};
            const State* tmp = &actualGoal;
            while (tmp != nullptr) {
                debug("adding ", tmp, "to solution");
                result->addHead(*tmp);
                tmp = tmp->getParent();
            }
            return std::unique_ptr<StateSolutionPath<State>>{result};
        }
        virtual cost_t getSolutionCostFromGoalFetched(const State& start, const State& actualGoal, const State* goal) const {
            return actualGoal.getCost();
        }
        virtual const State& performSearch(State& start, const State* expectedGoal) {
            c_info("*********************** NEW SEARCH *******************");
            if (expectedGoal != nullptr) {
                c_info("starting A*! start = ", start, "goal = ", *expectedGoal);
            } else {
                c_info("starting A*! start = ", start, "goal = ", "none");
            }
            

            int aStarIteration = 0;
            const State* goal = nullptr;
            cost_t upperbound = cost_t::INFTY;
            //we might be able to early terminate from start. In this case the state where we start early terminating is the start itself
            const State* earlyTerminationState = &start;

            start.setG(0);
            this->fireEvent([&start, aStarIteration](Listener& l) {l.onStartingComputingHeuristic(aStarIteration, start); });
            start.setH(this->heuristic.getHeuristic(start, expectedGoal));
            this->fireEvent([&start, aStarIteration](Listener& l) {l.onEndingComputingHeuristic(aStarIteration, start); });
            //the start has discount factor of 1
            start.setF(this->computeF(start.getG(), start.getH(), start.getDiscount()));

            //update lastEarliestPerturbationSourceId
            start.updateEarlyPerturbationInfo(
                this->heuristic.getLastEarliestNodeBeforePerturbation(),
                this->heuristic.getLastEarliestPerturbationSourceIdCost()
            );
            start.updatePerturbatedPathCostToGoal(this->heuristic.getCPDPathPerturbatedWeights(start.getPosition()));

            //update lower and upper bound from f of solution
            cost_t lowerbound = start.getH();
            upperbound = this->heuristic.getCPDPathPerturbatedWeights(start.getPosition());

            this->openList->push(start);
            while (!this->openList->isEmpty()) {
                c_info("*************** A* step #", aStarIteration, "******************");
                State& current = this->openList->peek();
                //current.getF() is also a lowerbound since the heuristic is admissible
                lowerbound = current.getF();
                c_info("state ", current, "popped from open list f=", current.getF(), "g=", current.getG(), "h=", current.getH(), " pointer=", &current, "parent pointer=", current.getParent(), "lowerbound=", lowerbound, "upperbound=", upperbound, "eps_numerator=", this->epsilon.getNumerator(), "eps_denominator=", this->epsilon.getDenominator());

                //check if the peeked state is actually a goal
                if (this->goalChecker.isGoal(current, expectedGoal)) {
                    c_info("state ", current, "is a goal!");
                    goal = &current;

                    this->fireEvent([&, goal](Listener& l) { l.onSolutionFound(aStarIteration, *goal);});
                    goto goal_found;
                }

                this->openList->pop();
                

                /*
                * upperbound/lowebound <= epsilon 
                * which we derive
                * eps * lowerbound >= upperbound
                */
               c_info("(", this->epsilon.getNumerator(), "*", current.getF(), ") >= (", upperbound, "*", this->epsilon.getDenominator(), ")");
                if ((this->epsilon.getNumerator() * current.getF()) >= (upperbound * this->epsilon.getDenominator())) {
                    //return the solution by concatenating the current path from start to current and the cpdpath from current to goal
                    //(considering the perturbations!)
                    c_info("epsilon * lowerbound >= upperbound! ", epsilon, "*", current.getF(), ">=", upperbound);
                    c_info("early terminating from ", *earlyTerminationState, "up until ", *expectedGoal);
                    goal = this->earlyTerminate(*earlyTerminationState, expectedGoal);
                    this->fireEvent([&, earlyTerminationState, goal, aStarIteration](Listener& l) {l.onEarlyTerminationActivated(aStarIteration, *earlyTerminationState, *goal); });
                    this->fireEvent([&, goal](Listener& l) { l.onSolutionFound(aStarIteration, *goal);});
                    goto goal_found;
                }

                current.markAsExpanded();
                this->fireEvent([&current, aStarIteration](Listener& l) {l.onNodeExpanded(aStarIteration, current); });

                c_info("computing successors of state ", current, "...");
                //since it is the expander that generate the successors and knows which state is generated by following the cpd path and which isn't, it has the job of updating the discount factor whenever it is possible
                for(auto pair: this->expander.getSuccessors(current, this->supplier)) {
                    State& successor = pair.first;
                    cost_t current_to_successor_cost = pair.second;

                    if (this->pruner.shouldPrune(successor)) {
                        c_info("child", successor, "of state ", current, "should be pruned!");
                        //skip neighbours already expanded
                        continue;
                    }

                    if (successor.isExpanded()) {
                        //the node already been closed
                        continue;
                    }

                    // the search is suboptimal. So a state in the closed list can be reopened
                    if (this->openList->contains(successor)) {
                        //state inside the open list. Check if we need to update the path
                        cost_t gval = current.getG() + current_to_successor_cost;
                        if (gval >= successor.getG()) {
                            c_info(successor, " is in open but the new path for reaching the state is not better than the current one. Ignoring");
                            continue;
                        }

                        c_info("child", successor, "of state ", current, "present in open list and has a lower g. update its parent!");

                        //update successor information
                        successor.setG(gval);
                        successor.setF(this->computeF(gval, successor.getH(), successor.getDiscount()));
                        const State* oldParent = successor.getParent();
                        successor.setParent(&current);

                        this->openList->decrease_key(successor);
                    } else {
                        //state is not present in open list. Add to it
                        cost_t gval = current.getG() + current_to_successor_cost;
                        this->fireEvent([&successor, aStarIteration](Listener& l) {l.onStartingComputingHeuristic(aStarIteration, successor); });
                        cost_t hval = this->heuristic.getHeuristic(successor, expectedGoal);
                        this->fireEvent([&successor, aStarIteration](Listener& l) {l.onEndingComputingHeuristic(aStarIteration, successor); });

                        //update lastEarliestPerturbationSourceId
                        successor.updateEarlyPerturbationInfo(
                            this->heuristic.getLastEarliestNodeBeforePerturbation(),
                            this->heuristic.getLastEarliestPerturbationSourceIdCost()
                        );
                        successor.updatePerturbatedPathCostToGoal(this->heuristic.getCPDPathPerturbatedWeights(successor.getPosition()));
                        
                        successor.setG(gval);
                        successor.setH(hval);
                        successor.setF(this->computeF(gval, hval, successor.getDiscount()));
                        successor.setParent(&current);
                        this->fireEvent([&successor, aStarIteration](Listener& l) {l.onNodeGenerated(aStarIteration, successor); });

                        //we may have a new upperbound of the solution
                        if (upperbound > gval + this->heuristic.getLastPerturbatedCost()) {
                            c_info("updating upperbound. upperbound: from", upperbound, "to", gval + this->heuristic.getLastPerturbatedCost());
                            if (earlyTerminationState == nullptr) {
                                c_info("updating incumbent. incumbent: from null to", successor);
                            } else {
                                c_info("updating incumbent. incumbent: from", *earlyTerminationState, "to", successor);
                            }
                            
                            auto newupperbound = gval + this->heuristic.getLastPerturbatedCost();
                            this->fireEvent([&successor, &upperbound, &newupperbound, aStarIteration](Listener& l) {l.onUpperboundRevised(aStarIteration, successor, upperbound, newupperbound); });
                            upperbound = newupperbound;

                            earlyTerminationState = &successor;
                        }

                        c_info("child", successor, "of state ", current, "not present in open list. Add it f=", successor.getF(), "g=", successor.getG(), "h=", successor.getH());
                        this->openList->push(successor);
                    }
                }

                aStarIteration += 1;
            }
            info("found no solutions!");
            throw SolutionNotFoundException{};

            goal_found:
            return *goal;

        }
    private:
        /**
         * @brief perform the early termination routine
         * 
         * the routine will generate the intermediate nodes are well. Each intermediate node is generated as follows:
         * @li g always updated to the new value (even if it is higher than the current one)
         * @li parent always update it (even if not optimal)
         * @li h always set to \f$ +\infty \f$ (to avoid overhead time).
         * 
         * This mechanismk woprks for optimal algorithms, since we know that the node we are expanding is the optimal one up until now.
         * 
         * @param state the state where we start early terminating
         * @param expectedGoal the goal to reach
         * @return const State* the state representing the goal rached
         */
        const State* earlyTerminate(const State& state, const State* expectedGoal) {
            moveid_t nextMove;
            nodeid_t nextVertex;
            cost_t originalMoveCost;
            const State* currentState = &state;
            nodeid_t goalVertex = expectedGoal->getPosition();
            
            while (true) {
                if (this->goalChecker.isGoal(*currentState, expectedGoal)) {
                    return currentState;
                }
                if (this->cpdManager.getFirstMove(currentState->getPosition(), goalVertex, nextMove, nextVertex, originalMoveCost)) {
                    std::pair<State&, cost_t> pair = this->expander.getSuccessor(*currentState, nextMove, this->supplier);
                    State& successor = pair.first;
                    cost_t actionCost = pair.second;
                    successor.setParent(const_cast<State*>(currentState));
                    successor.setG(currentState->getG() + actionCost);
                    successor.setH(cost_t::INFTY);
                    currentState = &successor;
                } else {
                    throw cpp_utils::exceptions::ImpossibleException{};
                }
            }
        }
    };

    /**
     * @brief simple class that create the cpd jump search more easily
     * 
     */
    class CpdJumpTrailSearchFactory {
    public:
        template <typename G, typename V>
        struct output_t {
        public:
            using State = DiscountedCpdState<G, V, PerturbatedCost, cpd_search_generated_e>;
        public:
            /**
             * @brief place where the goal checker is located in memory
             * 
             */
            StandardLocationGoalChecker<State> goalChecker;
            /**
             * @brief place where the state supplier is located in memory
             * 
             */
            DiscountedCpdStateSupplier<G, V, PerturbatedCost> stateSupplier;
            /**
             * @brief place where the state pruner is located in memory
             * 
             */
            NeverPrune<State> statePruner;
            /**
             * @brief place where the heuristic is located
             * 
             */
            CpdFocalHeuristic<State, G, V> heuristic;
            /**
             * @brief place where the state expander is located in memory
             * 
             * @note this needs to be the last field declared here, since its dependent on the heuristic.
             * @see https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP53-CPP.+Write+constructor+member+initializers+in+the+canonical+order
             */
            CpdTrailExpander<G, V, State> stateExpander;
            /**
             * @brief place where CPD timed search algorithm is located
             * 
             * @note this needs to be the last field declared here, since its dependent on other fields.
             * @see https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP53-CPP.+Write+constructor+member+initializers+in+the+canonical+order
             */
            CpdJumpTrailSearch<G, V> search;
        public:
            output_t(
                const CpdManager<G, V>& cpdManager,
                const IImmutableGraph<G, V, PerturbatedCost>& perturbatedGraph,
                fractional_cost epsilon,
                double minDiscount, double maxDiscount, double discountDecay
                ): 
                goalChecker{}, 
                heuristic{cpdManager, perturbatedGraph},
                stateSupplier{perturbatedGraph}, 
                stateExpander{perturbatedGraph, this->heuristic, minDiscount, maxDiscount, discountDecay}, 
                statePruner{},
                search{this->heuristic, this->goalChecker, this->stateSupplier, this->stateExpander, this->statePruner, this->heuristic.getCpdManager(), epsilon, 1024} {
                    debug("output factory constructor correctly called!");
            }

            output_t(const output_t& other) = delete;
            output_t(output_t&& other) noexcept : search{::std::move(other.search)}, heuristic(std::move(other.heuristic)), goalChecker(std::move(other.goalChecker)), stateSupplier(std::move(other.stateSupplier)), stateExpander(std::move(other.stateExpander)), statePruner(std::move(other.statePruner)) {
                debug("output factory move constructor correctly called!");
            }
            output_t& operator =(const output_t& other) = delete;
            output_t& operator =(output_t&& other) {
                debug("calling factory move =!");
                this->search = std::move(other.search);
                this->heuristic = std::move(other.heuristic);
                this->goalChecker = std::move(other.goalChecker);
                this->stateSupplier = std::move(other.stateSupplier);
                this->stateExpander = std::move(other.stateExpander);
                this->statePruner = std::move(other.statePruner);

                debug("output factory move = correctly called!");
                return *this;
            }
            virtual ~output_t() {
                debug("output destructed!");
            }
        };
    public:
        /**
         * @brief cpd search on gridmaps
         * 
         * @tparam G payload of the whole graph involved
         * @tparam V payload of a single vertex in the graph
         * 
         * @param[in] cpdManager manager for the cpd. 
         * @param[in] perturbations the perturbation you want to apply to the graph
         * @param[in] epsilon bound
         * @return cpd search algorithm
         */
        template <typename G, typename V>
        output_t<G,V>* get(const CpdManager<G,V>& cpdManager, const IImmutableGraph<G, V, PerturbatedCost>& perturbatedGraph, fractional_cost epsilon, double minDiscount, double maxDiscount, double discountDecay) {
            debug("generating output...");
            return new output_t<G, V>{
                cpdManager,
                perturbatedGraph,
                epsilon,
                minDiscount, maxDiscount, discountDecay
            };
        }
    };

}

#endif